<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Package Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@2.13.0/dist/graphviz.umd.js"></script>
    <script src="https://unpkg.com/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'JetBrains Mono', monospace !important;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        .graph-container {
            background: transparent;
            width: 100%;
            height: 100vh;
            position: relative;
        }
        .graph-container svg {
            width: 100%;
            height: 100%;
            opacity: 0;
        }
        .graph-container svg.visible {
            opacity: 1;
        }
        .zoom-controls {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 100;
            display: flex;
            flex-direction: row;
            gap: 0;
        }
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 1);
            border: none;
            color: rgba(255, 255, 255, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 0;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            padding: 0;
            transition: color 75ms ease;
        }
        .zoom-btn:hover {
            color: rgba(255, 255, 255, 1);
        }
        #resultsContainer {
            height: 100vh;
        }
        .cog-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 1);
            border: none;
            color: rgba(255, 255, 255, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 0;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            padding: 0;
            transition: color 75ms ease;
        }
        .cog-btn:hover {
            color: rgba(255, 255, 255, 1);
        }
    </style>
</head>
<body class="bg-black text-white" style="margin: 0; padding: 0; height: 100vh">
    <!-- Error Display -->
    <div id="errorContainer" class="fixed top-4 left-4 right-4 bg-red-900 border border-red-700 rounded-md p-4 z-50 hidden">
        <div class="flex">
            <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
            </div>
            <div class="ml-3">
                <h3 class="text-sm font-medium text-red-200">Error</h3>
                <div class="mt-2 text-sm text-red-300">
                    <p id="errorMessage"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Results -->
    <div id="resultsContainer" class="hidden" style="height: 100vh; display: flex; flex-direction: column; overflow: hidden;">
        <!-- Entry Point Selector -->
        <div id="entryPointSelector" class="hidden fixed top-0 left-0 right-0 p-0 z-40">
            <div class="flex items-center space-x-4 flex-wrap gap-y-2">
                <div class="flex items-center space-x-2">
<!--                     <label for="entryPointSelect" class="text-sm font-medium text-gray-300">Entry Point:</label>-->
                    <select id="entryPointSelect" class="bg-black border border-black text-white px-3 py-1 h-[40px] text-sm focus:outline-none focus:border-black cursor-pointer" onchange="switchEntryPoint()">
                        <!-- Options will be populated dynamically -->
                    </select>
                    <button id="excludeToggleBtn" class="cog-btn" onclick="toggleExcludeSection()" title="Toggle exclude options">⚙</button>
                </div>
                
                <div id="excludeSection" class="flex items-center space-x-2 hidden">
                    <label for="excludeInput" class="text-sm font-medium text-gray-300">Exclude:</label>
                    <input 
                        id="excludeInput" 
                        type="text" 
                        placeholder=""
                        class="bg-black border border-white/20 text-white px-3 py-1 text-sm focus:outline-none focus:border-white w-48"
                        oninput="handleExcludeChange()" 
                    />
                </div>
            </div>
        </div>
        
        <div id="graphContainer" class="graph-container" style="flex: 1; padding-top: 0;">
            <div class="text-gray-400">
                <svg class="w-16 h-16 mx-auto mb-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                </svg>
                <p>Graph will appear here</p>
            </div>
        </div>

        <!-- Pan/Zoom Controls -->
        <div class="zoom-controls select-none">
            <div class="zoom-btn" onclick="zoomIn()">+</div>
            <div class="zoom-btn" onclick="zoomOut()">-</div>
            <div class="zoom-btn" onclick="fitAndCenter()" title="Fit and center graph">•</div>
        </div>
    </div>

    <!-- URL Parameter Detection -->
    <script>
        // Global variables
        let currentDOTData = '';
        let currentSVGData = '';
        let entryPointsData = []; // Store all entry points data
        let currentEntryPointIndex = 0; // Currently selected entry point
        let currentRepoRoot = ''; // Store current repository root
        let excludeDebounceTimer = null; // Timer for debouncing exclude input
        const EXCLUDE_DEBOUNCE_DELAY = 1000; // 1 second debounce delay
        
        // Arrow key navigation state
        let arrowKeysPressed = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        let panAnimationID = null;
        const PAN_SPEED = 12; // pixels per frame - base speed that affects all zoom levels
        const ZOOM_PAN_MODIFIER = 0.6; // float between -1 and 1: 0=no zoom effect, -1=fast when zoomed out, 1=fast when zoomed in

        // Zoom key navigation state
        let zoomKeysPressed = {
            zoomIn: false,
            zoomOut: false
        };
        let zoomAnimationId = null;
        const ZOOM_SPEED = 0.02; // zoom factor per frame (multiplicative)

        // Pan/Zoom functionality
        // SVG Pan/Zoom instance
        let panZoomInstance = null;

        function initializePanZoom(svgElement) {
            console.log('Initializing pan/zoom with element:', svgElement);
            
            // Check if svg-pan-zoom is available
            if (typeof svgPanZoom === 'undefined') {
                console.error('svg-pan-zoom library not loaded!');
                return null;
            }
            
            // Destroy existing instance if it exists
            if (panZoomInstance) {
                panZoomInstance.destroy();
            }

            // Initialize svg-pan-zoom without automatic fitting
            panZoomInstance = svgPanZoom(svgElement, {
                zoomEnabled: true,
                panEnabled: true,
                controlIconsEnabled: false,
                dblClickZoomEnabled: false,
                mouseWheelZoomEnabled: true,
                preventMouseEventsDefault: true,
                zoomScaleSensitivity: 0.2,
                minZoom: 0.1,
                maxZoom: 5,
                fit: false, // We'll handle fitting manually
                contain: false,
                center: false, // We'll handle centering manually
                refreshRate: 'auto'
            });

            console.log('svg-pan-zoom instance created:', panZoomInstance);
            
            // Apply our custom fit after a short delay
            setTimeout(() => {
                fitAndCenter();
            }, 100);
            
            return panZoomInstance;
        }

        function fitAndCenter() {
            if (!panZoomInstance) {
                console.log('Cannot fit: no panZoom instance');
                return;
            }

            try {
                console.log('=== Starting fitAndCenter ===');
                
                const container = document.getElementById('graphContainer');
                const svgElement = container.querySelector('svg');
                
                if (!svgElement) {
                    console.log('No SVG element found');
                    return;
                }
                
                // Hide the SVG during reset and repositioning to prevent flickering
                const wasVisible = svgElement.classList.contains('visible');
                svgElement.classList.remove('visible');
                
                // Always reset to clean state first - this is crucial for idempotent behavior
                console.log('Resetting to clean state...');
                panZoomInstance.resetZoom();
                panZoomInstance.resetPan();
                
                // Force refresh dimensions after reset
                panZoomInstance.resize();
                
                // Call updateBBox if it exists (some versions of svg-pan-zoom have this)
                if (typeof panZoomInstance.updateBBox === 'function') {
                    panZoomInstance.updateBBox();
                }
                
                // Small delay to ensure reset is complete, then do calculations and apply
                setTimeout(() => {
                    try {
                        // Force refresh the container dimensions to handle window resizing
                        // Ensure container takes full viewport
                        const body = document.body;
                        const html = document.documentElement;
                        container.style.width = '100%';
                        container.style.height = '100vh';
                        
                        // Force a reflow to ensure dimensions are updated
                        container.offsetHeight;
                        
                        // Get current container dimensions after any resize
                        const containerRect = container.getBoundingClientRect();
                        let containerWidth = containerRect.width;
                        let containerHeight = containerRect.height;
                        
                        // Fallback to window dimensions if container dimensions are invalid
                        if (containerWidth <= 0 || containerHeight <= 0) {
                            containerWidth = window.innerWidth;
                            containerHeight = window.innerHeight;
                            console.log('Using window dimensions as fallback:', { width: containerWidth, height: containerHeight });
                        }
                        
                        console.log('Container dimensions:', { width: containerWidth, height: containerHeight });
                        
                        // Get SVG content bounds - this should be consistent after reset
                        const bbox = svgElement.getBBox();
                        console.log('SVG bounds:', bbox);
                        
                        // Calculate scale to fit with padding
                        const padding = 50;
                        const availableWidth = containerWidth - (padding * 2);
                        const availableHeight = containerHeight - (padding * 2);
                        
                        // Ensure we have positive dimensions
                        if (availableWidth <= 0 || availableHeight <= 0 || bbox.width <= 0 || bbox.height <= 0) {
                            console.error('Invalid dimensions for fitting:', {
                                availableWidth, availableHeight,
                                bboxWidth: bbox.width, bboxHeight: bbox.height
                            });
                            svgElement.classList.add('visible');
                            return;
                        }
                        
                        const scaleX = availableWidth / bbox.width;
                        const scaleY = availableHeight / bbox.height;
                        const targetScale = Math.min(scaleX, scaleY, 1); // Don't zoom beyond 100%
                        
                        console.log('Calculated target scale:', targetScale, 'from scales:', { scaleX, scaleY });
                        
                        // Use the library's built-in methods for reliable positioning
                        // First fit the content to the calculated scale
                        panZoomInstance.zoom(targetScale);
                        
                        // Then use the library's center method which handles coordinate systems correctly
                        panZoomInstance.center();
                        
                        console.log('Applied zoom and center using library methods');
                        
                        // Get final state for debugging
                        const finalSizes = panZoomInstance.getSizes();
                        console.log('Final state after library center:', finalSizes);
                        
                        // Show the result
                        setTimeout(() => {
                            svgElement.classList.add('visible');
                            console.log('=== fitAndCenter completed ===');
                        }, 10);
                        
                    } catch (delayedError) {
                        console.error('Error in delayed fitAndCenter execution:', delayedError);
                        // Make sure to show the SVG even on error
                        svgElement.classList.add('visible');
                    }
                }, 50); // Small delay to ensure reset is processed
                
            } catch (error) {
                console.error('Error in fitAndCenter:', error);
                
                // Simple fallback - just make visible and try basic library methods
                try {
                    panZoomInstance.resetZoom();
                    panZoomInstance.resetPan();
                    
                    // Still make visible even on fallback
                    const container = document.getElementById('graphContainer');
                    const svgElement = container.querySelector('svg');
                    if (svgElement) {
                        svgElement.classList.add('visible');
                    }
                } catch (fallbackError) {
                    console.error('Fallback also failed:', fallbackError);
                }
            }
        }

        function zoomIn() {
            if (panZoomInstance) {
                panZoomInstance.zoomIn();
            }
        }

        function zoomOut() {
            if (panZoomInstance) {
                panZoomInstance.zoomOut();
            }
        }

        // Helper function to check if exclude input is focused
        function isExcludeInputFocused() {
            const excludeInput = document.getElementById('excludeInput');
            return excludeInput && document.activeElement === excludeInput;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const repoRoot = urlParams.get('repo');
            
            if (!repoRoot) {
                // Show error message for missing repo parameter
                showError('No repository root specified. Please provide a repository root path as a URL parameter (e.g., ?repo=/path/to/project)');
                return;
            }

            // Start analysis automatically
            analyzeRepository();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Skip all graph hotkeys if exclude input is focused
            if (isExcludeInputFocused()) {
                return;
            }

            // Check for Ctrl+0 (or Cmd+0 on Mac) - fit and center
            if ((event.ctrlKey || event.metaKey) && event.key === '0') {
                event.preventDefault(); // Prevent browser's default zoom reset
                fitAndCenter();
            }
            // Check for Ctrl+Plus (or Cmd+Plus on Mac) - zoom in
            else if ((event.ctrlKey || event.metaKey) && (event.key === '+' || event.key === '=')) {
                event.preventDefault(); // Prevent browser's default zoom in
                zoomIn();
            }
            // Check for Ctrl+Minus (or Cmd+Minus on Mac) - zoom out
            else if ((event.ctrlKey || event.metaKey) && event.key === '-') {
                event.preventDefault(); // Prevent browser's default zoom out
                zoomOut();
            }
            // Check for Ctrl+Up Arrow (or Cmd+Up Arrow on Mac) - zoom in
            else if ((event.ctrlKey || event.metaKey) && event.key === 'ArrowUp') {
                event.preventDefault(); // Prevent browser's default behavior
                zoomKeysPressed.zoomIn = true;
                startZoomAnimation();
            }
            // Check for Ctrl+Down Arrow (or Cmd+Down Arrow on Mac) - zoom out
            else if ((event.ctrlKey || event.metaKey) && event.key === 'ArrowDown') {
                event.preventDefault(); // Prevent browser's default behavior
                zoomKeysPressed.zoomOut = true;
                startZoomAnimation();
            }
            // Check for Ctrl+Left Arrow or Ctrl+Right Arrow - track for fit and center combo
            else if ((event.ctrlKey || event.metaKey) && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
                event.preventDefault(); // Prevent browser's default behavior
                
                // Track which arrow keys are pressed with Ctrl/Cmd
                if (event.key === 'ArrowLeft') {
                    window.ctrlLeftPressed = true;
                } else if (event.key === 'ArrowRight') {
                    window.ctrlRightPressed = true;
                }
                
                // If both left and right arrows are pressed with Ctrl/Cmd, fit and center
                if (window.ctrlLeftPressed && window.ctrlRightPressed) {
                    fitAndCenter();
                    // Reset the tracking
                    window.ctrlLeftPressed = false;
                    window.ctrlRightPressed = false;
                }
            }
        });

        // Track when Ctrl/Cmd arrow keys are released
        document.addEventListener('keyup', function(event) {
            // Skip all graph hotkeys if exclude input is focused
            if (isExcludeInputFocused()) {
                return;
            }

            if (event.key === 'ArrowLeft') {
                window.ctrlLeftPressed = false;
            } else if (event.key === 'ArrowRight') {
                window.ctrlRightPressed = false;
            } else if (event.key === 'ArrowUp') {
                zoomKeysPressed.zoomIn = false;
                // Stop zoom animation if no zoom keys are pressed
                if (!zoomKeysPressed.zoomIn && !zoomKeysPressed.zoomOut) {
                    stopZoomAnimation();
                }
            } else if (event.key === 'ArrowDown') {
                zoomKeysPressed.zoomOut = false;
                // Stop zoom animation if no zoom keys are pressed
                if (!zoomKeysPressed.zoomIn && !zoomKeysPressed.zoomOut) {
                    stopZoomAnimation();
                }
            }
        });

        // Mouse wheel shortcuts - override browser zoom when Ctrl/Cmd is pressed
        document.addEventListener('wheel', function(event) {
            // Skip if exclude input is focused
            if (isExcludeInputFocused()) {
                return;
            }

            // Check if Ctrl/Cmd is pressed with mouse wheel
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault(); // Prevent browser's default zoom behavior
                // The svg-pan-zoom library will handle the wheel event on the SVG element
                // We just need to prevent the browser's default behavior here
            }
        }, { passive: false }); // passive: false allows preventDefault to work

        // Arrow key navigation for panning
        document.addEventListener('keydown', function(event) {
            // Skip all graph hotkeys if exclude input is focused
            if (isExcludeInputFocused()) {
                return;
            }

            // Handle arrow keys for panning (don't interfere with other shortcuts)
            if (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
                let handled = false;
                
                switch(event.key) {
                    case 'ArrowUp':
                        arrowKeysPressed.up = true;
                        // Track for fit and center combination
                        window.pageUpArrowPressed = true;
                        handled = true;
                        break;
                    case 'ArrowDown':
                        arrowKeysPressed.down = true;
                        handled = true;
                        break;
                    case 'ArrowLeft':
                        arrowKeysPressed.left = true;
                        handled = true;
                        break;
                    case 'ArrowRight':
                        arrowKeysPressed.right = true;
                        handled = true;
                        break;
                    case 'w':
                    case 'W':
                        arrowKeysPressed.up = true;
                        handled = true;
                        break;
                    case 's':
                    case 'S':
                        arrowKeysPressed.down = true;
                        handled = true;
                        break;
                    case 'a':
                    case 'A':
                        arrowKeysPressed.left = true;
                        handled = true;
                        break;
                    case 'd':
                    case 'D':
                        arrowKeysPressed.right = true;
                        handled = true;
                        break;
                    case 'PageDown':
                        zoomKeysPressed.zoomOut = true;
                        // Track for fit and center combination
                        window.pageDownPressed = true;
                        handled = true;
                        break;
                    case 'PageUp':
                        zoomKeysPressed.zoomIn = true;
                        // Track for fit and center combination
                        window.pageUpPressed = true;
                        handled = true;
                        break;
                    case ' ':
                        // Space bar for fit and center
                        event.preventDefault(); // Prevent default browser scroll behavior
                        fitAndCenter();
                        handled = true;
                        break;
                }
                
                // // Check for PageUp + ArrowUp + PageDown combination for fit and center
                // if (window.pageUpPressed && window.pageUpArrowPressed && window.pageDownPressed) {
                //     fitAndCenter();
                //     // Reset the tracking
                //     window.pageUpPressed = false;
                //     window.pageUpArrowPressed = false;
                //     window.pageDownPressed = false;
                //     // Also stop zoom animations since we're resetting
                //     zoomKeysPressed.zoomIn = false;
                //     zoomKeysPressed.zoomOut = false;
                //     stopZoomAnimation();
                // }
                
                if (handled) {
                    event.preventDefault(); // Prevent default browser scrolling/page navigation
                    if (arrowKeysPressed.up || arrowKeysPressed.down || arrowKeysPressed.left || arrowKeysPressed.right) {
                        startPanAnimation();
                    }
                    if (zoomKeysPressed.zoomIn || zoomKeysPressed.zoomOut) {
                        startZoomAnimation();
                    }
                }
            }
        });

        document.addEventListener('keyup', function(event) {
            // Skip all graph hotkeys if exclude input is focused
            if (isExcludeInputFocused()) {
                return;
            }

            // Handle arrow key releases
            let handled = false;
            
            switch(event.key) {
                case 'ArrowUp':
                    arrowKeysPressed.up = false;
                    window.pageUpArrowPressed = false;
                    handled = true;
                    break;
                case 'ArrowDown':
                    arrowKeysPressed.down = false;
                    handled = true;
                    break;
                case 'ArrowLeft':
                    arrowKeysPressed.left = false;
                    handled = true;
                    break;
                case 'ArrowRight':
                    arrowKeysPressed.right = false;
                    handled = true;
                    break;
                case 'w':
                case 'W':
                    arrowKeysPressed.up = false;
                    handled = true;
                    break;
                case 's':
                case 'S':
                    arrowKeysPressed.down = false;
                    handled = true;
                    break;
                case 'a':
                case 'A':
                    arrowKeysPressed.left = false;
                    handled = true;
                    break;
                case 'd':
                case 'D':
                    arrowKeysPressed.right = false;
                    handled = true;
                    break;
                case 'PageDown':
                    zoomKeysPressed.zoomOut = false;
                    window.pageDownPressed = false;
                    handled = true;
                    break;
                case 'PageUp':
                    zoomKeysPressed.zoomIn = false;
                    window.pageUpPressed = false;
                    handled = true;
                    break;
            }
            
            if (handled) {
                // Stop pan animation if no arrow keys are pressed
                if (!arrowKeysPressed.up && !arrowKeysPressed.down && 
                    !arrowKeysPressed.left && !arrowKeysPressed.right) {
                    stopPanAnimation();
                }
                // Stop zoom animation if no zoom keys are pressed
                if (!zoomKeysPressed.zoomIn && !zoomKeysPressed.zoomOut) {
                    stopZoomAnimation();
                }
            }
        });

        function startPanAnimation() {
            if (panAnimationId || !panZoomInstance) return;
            
            function animatePan() {
                // Get current zoom level and calculate zoom-adjusted speed
                const currentZoom = panZoomInstance.getZoom();
                
                // Calculate zoom adjustment factor based on ZOOM_PAN_MODIFIER
                // At modifier=0: no zoom effect (factor=1)
                // At modifier=-1: fast when zoomed out (factor=1/zoom), slow when zoomed in
                // At modifier=1: slow when zoomed out, fast when zoomed in (factor=zoom)
                let zoomFactor = 1;
                if (ZOOM_PAN_MODIFIER !== 0) {
                    if (ZOOM_PAN_MODIFIER < 0) {
                        // Negative modifier: speed inversely proportional to zoom
                        zoomFactor = Math.pow(1 / currentZoom, Math.abs(ZOOM_PAN_MODIFIER));
                    } else {
                        // Positive modifier: speed proportional to zoom
                        zoomFactor = Math.pow(currentZoom, ZOOM_PAN_MODIFIER);
                    }
                }
                
                const zoomAdjustedSpeed = PAN_SPEED * zoomFactor;
                
                // Calculate movement direction (reversed for intuitive navigation)
                let deltaX = 0;
                let deltaY = 0;
                
                if (arrowKeysPressed.left) deltaX += zoomAdjustedSpeed;
                if (arrowKeysPressed.right) deltaX -= zoomAdjustedSpeed;
                if (arrowKeysPressed.up) deltaY += zoomAdjustedSpeed;
                if (arrowKeysPressed.down) deltaY -= zoomAdjustedSpeed;
                
                // Apply panning if any movement is needed
                if (deltaX !== 0 || deltaY !== 0) {
                    panZoomInstance.panBy({ x: deltaX, y: deltaY });
                }
                
                // Continue animation if any keys are still pressed
                if (arrowKeysPressed.up || arrowKeysPressed.down || 
                    arrowKeysPressed.left || arrowKeysPressed.right) {
                    panAnimationId = requestAnimationFrame(animatePan);
                } else {
                    panAnimationId = null;
                }
            }
            
            panAnimationId = requestAnimationFrame(animatePan);
        }

        function stopPanAnimation() {
            if (panAnimationID) {
                cancelAnimationFrame(panAnimationID);
                panAnimationId = null;
            }
        }

        function startZoomAnimation() {
            if (zoomAnimationId || !panZoomInstance) return;
            
            function animateZoom() {
                // Calculate zoom direction
                let zoomMultiplier = 1;
                
                if (zoomKeysPressed.zoomIn) {
                    zoomMultiplier += ZOOM_SPEED;
                }
                if (zoomKeysPressed.zoomOut) {
                    zoomMultiplier -= ZOOM_SPEED;
                }
                
                // Apply zooming if any zoom change is needed
                if (zoomMultiplier !== 1) {
                    const currentZoom = panZoomInstance.getZoom();
                    const newZoom = currentZoom * zoomMultiplier;
                    
                    // Respect zoom limits
                    const minZoom = 0.1;
                    const maxZoom = 5;
                    if (newZoom >= minZoom && newZoom <= maxZoom) {
                        panZoomInstance.zoom(newZoom);
                    }
                }
                
                // Continue animation if any zoom keys are still pressed
                if (zoomKeysPressed.zoomIn || zoomKeysPressed.zoomOut) {
                    zoomAnimationId = requestAnimationFrame(animateZoom);
                } else {
                    zoomAnimationId = null;
                }
            }
            
            zoomAnimationId = requestAnimationFrame(animateZoom);
        }

        function stopZoomAnimation() {
            if (zoomAnimationID) {
                cancelAnimationFrame(zoomAnimationID);
                zoomAnimationId = null;
            }
        }

        async function analyzeRepository() {
            const urlParams = new URLSearchParams(window.location.search);
            const repoRoot = urlParams.get('repo');
            const showExternal = urlParams.get('external') === 'true';

            // Store current repo root
            currentRepoRoot = repoRoot;

            // Keep page blank during analysis - no need to hide anything
            hideError();
            hideResults();
            hideEntryPointSelector();

            try {
                // Build query parameters for initial repository analysis
                const params = new URLSearchParams({
                    repo: repoRoot,
                    external: showExternal.toString(),
                });

                // Make API request
                const response = await fetch(`/api/analyze-repo?${params.toString()}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Unknown error occurred');
                }

                // Store entry points data
                entryPointsData = data.entryPoints;

                if (entryPointsData.length === 0) {
                    throw new Error('No entry points found in the repository');
                }

                // Try to load the remembered entry point for this repo
                const rememberedEntryPointPath = loadSelectedEntryPoint(currentRepoRoot);
                currentEntryPointIndex = 0; // Default to first entry point

                if (rememberedEntryPointPath) {
                    // Find the index of the remembered entry point
                    const rememberedIndex = entryPointsData.findIndex(ep => ep.relativePath === rememberedEntryPointPath);
                    if (rememberedIndex >= 0) {
                        currentEntryPointIndex = rememberedIndex;
                    }
                }

                // Populate entry point selector
                populateEntryPointSelector();

                // Update exclude input for the first entry point (loads from localStorage)
                updateExcludeInput();

                // Check if the first entry point has a saved exclude list and re-analyze if needed
                const firstEntryPoint = entryPointsData[0];
                const excludeInput = document.getElementById('excludeInput');
                const excludeList = excludeInput.value.trim();

                if (excludeList) {
                    // Re-analyze the first entry point with the saved exclude list
                    await updateCurrentEntryPointWithExclude();
                } else {
                    // No exclude list, render the initial entry point as-is
                    await renderCurrentEntryPoint();
                }
                
                // Show results
                showResults();
                if (entryPointsData.length > 0) {
                    showEntryPointSelector();
                }

            } catch (error) {
                console.error('Error analyzing repository:', error);
                showError(error.message || 'Failed to analyze repository');
            }
        }

        function populateEntryPointSelector() {
            const select = document.getElementById('entryPointSelect');
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add options for each entry point
            entryPointsData.forEach((entryPoint, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = entryPoint.relativePath;
                if (index === currentEntryPointIndex) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // Update count display and hide dropdown if only one entry point
            if (entryPointsData.length === 1) {
                select.style.display = 'none';
                if (select.previousElementSibling) {
                    select.previousElementSibling.style.display = 'none'; // Hide label too
                }
            } else {
                select.style.display = 'block';
                if (select.previousElementSibling) {
                    select.previousElementSibling.style.display = 'block'; // Show label
                }
            }
            
            // Adjust graph container padding after content changes
            setTimeout(() => adjustGraphContainerForFixedHeader(), 10);
        }

        async function switchEntryPoint() {
            const select = document.getElementById('entryPointSelect');
            const newIndex = parseInt(select.value);
            
            if (newIndex !== currentEntryPointIndex && newIndex >= 0 && newIndex < entryPointsData.length) {
                currentEntryPointIndex = newIndex;
                
                // Save the selected entry point for this repo
                const selectedEntryPoint = entryPointsData[currentEntryPointIndex];
                saveSelectedEntryPoint(currentRepoRoot, selectedEntryPoint.relativePath);
                
                // Update exclude input for the new entry point
                updateExcludeInput();
                
                // Check if there's a saved exclude list for this entry point
                const savedExcludeList = loadExcludeList(selectedEntryPoint.relativePath);
                if (savedExcludeList && savedExcludeList.trim() !== '') {
                    // Re-analyze with the saved exclude list
                    await updateCurrentEntryPointWithExclude();
                } else {
                    // No excludes, just render the original graph
                    await renderCurrentEntryPoint();
                }
            }
        }

        async function renderCurrentEntryPoint() {
            if (currentEntryPointIndex >= 0 && currentEntryPointIndex < entryPointsData.length) {
                const entryPoint = entryPointsData[currentEntryPointIndex];
                currentDOTData = entryPoint.dotContent;
                await renderGraph(entryPoint.dotContent);
            }
        }

        function showEntryPointSelector() {
            const selector = document.getElementById('entryPointSelector');
            selector.classList.remove('hidden');
            adjustGraphContainerForFixedHeader();
        }

        function hideEntryPointSelector() {
            const selector = document.getElementById('entryPointSelector');
            selector.classList.add('hidden');
            adjustGraphContainerForFixedHeader();
        }

        function adjustGraphContainerForFixedHeader() {
            const selector = document.getElementById('entryPointSelector');
            const graphContainer = document.getElementById('graphContainer');
            
            if (selector && graphContainer) {
                // Always set padding to 0 to allow controls to overlap the graph
                graphContainer.style.paddingTop = '0';

                // if (selector.classList.contains('hidden')) {
                //     // No header visible, no padding needed
                //     graphContainer.style.paddingTop = '0';
                // } else {
                //     // Header is visible, add padding equal to header height
                //     const headerHeight = selector.offsetHeight;
                //     graphContainer.style.paddingTop = `${headerHeight}px`;
                // }
            }
        }

        // Toggle exclude section visibility
        function toggleExcludeSection() {
            const excludeSection = document.getElementById('excludeSection');
            const toggleBtn = document.getElementById('excludeToggleBtn');
            
            if (excludeSection.classList.contains('hidden')) {
                // Show exclude section
                excludeSection.classList.remove('hidden');
                toggleBtn.textContent = '◀'; // Left arrow
                toggleBtn.title = 'Hide exclude options';
            } else {
                // Hide exclude section
                excludeSection.classList.add('hidden');
                toggleBtn.textContent = '⚙'; // Cog
                toggleBtn.title = 'Toggle exclude options';
            }
        }

        // Exclude list management functions
        function getExcludeStorageKey(entryPointPath) {
            // Create a unique key for each repo + entry point combination
            const repoKey = currentRepoRoot || 'unknown-repo';
            const entryKey = entryPointPath || 'default';
            return `exclude_${btoa(repoKey + '::' + entryKey)}`;
        }

        function getSelectedEntryPointStorageKey(repoRoot) {
            // Create a unique key for each repo's selected entry point
            const repoKey = repoRoot || 'unknown-repo';
            return `selected_entry_${btoa(repoKey)}`;
        }

        function saveSelectedEntryPoint(repoRoot, entryPointPath) {
            const key = getSelectedEntryPointStorageKey(repoRoot);
            localStorage.setItem(key, entryPointPath);
        }

        function loadSelectedEntryPoint(repoRoot) {
            const key = getSelectedEntryPointStorageKey(repoRoot);
            return localStorage.getItem(key) || '';
        }

        function saveExcludeList(entryPointPath, excludeList) {
            const key = getExcludeStorageKey(entryPointPath);
            localStorage.setItem(key, excludeList);
        }

        function loadExcludeList(entryPointPath) {
            const key = getExcludeStorageKey(entryPointPath);
            return localStorage.getItem(key) || '';
        }

        function handleExcludeChange() {
            // Clear any existing timer
            if (excludeDebounceTimer) {
                clearTimeout(excludeDebounceTimer);
            }

            // Set up debounced re-request
            excludeDebounceTimer = setTimeout(async () => {
                await updateCurrentEntryPointWithExclude();
                excludeDebounceTimer = null;
            }, EXCLUDE_DEBOUNCE_DELAY);
        }

        async function updateCurrentEntryPointWithExclude() {
            if (currentEntryPointIndex < 0 || currentEntryPointIndex >= entryPointsData.length) {
                return;
            }

            const currentEntryPoint = entryPointsData[currentEntryPointIndex];
            const excludeInput = document.getElementById('excludeInput');
            const excludeList = excludeInput.value.trim();

            // Save exclude list to localStorage
            saveExcludeList(currentEntryPoint.relativePath, excludeList);

            try {
                // Re-analyze this specific entry point with the exclude list from textbox
                const urlParams = new URLSearchParams(window.location.search);
                const showExternal = urlParams.get('external') === 'true';

                const params = new URLSearchParams({
                    entry: currentEntryPoint.path,
                    external: showExternal.toString(),
                });

                // Always use the current textbox value, not URL params
                // Set exclude parameter explicitly (empty string if no excludes)
                params.set('exclude', excludeList);

                // Use the original single-entry API for re-analysis
                const response = await fetch(`/api/analyze?${params.toString()}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to update entry point');
                }

                // Update the entry point data
                entryPointsData[currentEntryPointIndex].dotContent = data.dot;

                // Re-render the current entry point
                await renderCurrentEntryPoint();

            } catch (error) {
                console.error('Error updating entry point with exclude list:', error);
                showError(`Failed to update exclude list: ${error.message}`);
            }
        }

        function updateExcludeInput() {
            // Update exclude input when switching entry points
            if (currentEntryPointIndex >= 0 && currentEntryPointIndex < entryPointsData.length) {
                const currentEntryPoint = entryPointsData[currentEntryPointIndex];
                const excludeInput = document.getElementById('excludeInput');
                
                // Load from localStorage for this entry point
                const savedExcludeList = loadExcludeList(currentEntryPoint.relativePath);
                excludeInput.value = savedExcludeList || '';
            }
        }

        async function renderGraph(dotData) {
            const container = document.getElementById('graphContainer');
            
            try {
                // Initialize Graphviz
                const graphviz = await window["@hpcc-js/wasm"].Graphviz.load();
                
                // Generate SVG from DOT - force recreation of graphviz instance for consistency
                const svg = graphviz.dot(dotData);
                
                // Store SVG data for download
                currentSVGData = svg;
                
                // Clear container and add SVG
                container.innerHTML = svg;
                
                // Add click listener to blur exclude input when clicking on graph
                container.addEventListener('click', function() {
                    const excludeInput = document.getElementById('excludeInput');
                    if (excludeInput && document.activeElement === excludeInput) {
                        excludeInput.blur();
                    }
                    
                    const entryPointSelect = document.getElementById('entryPointSelect');
                    if (entryPointSelect && document.activeElement === entryPointSelect) {
                        entryPointSelect.blur();
                    }
                });
                
                // Get the SVG element and set it up for pan/zoom
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    console.log('SVG element found, initializing pan/zoom...');
                    
                    // Make sure SVG is visible as fallback
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                    svgElement.style.display = 'block';
                    
                    // Wait a moment for SVG to be fully inserted into DOM
                    setTimeout(() => {
                        try {
                            const instance = initializePanZoom(svgElement);
                            if (instance) {
                                console.log('Pan/zoom initialized successfully');
                            } else {
                                console.log('Pan/zoom failed, but SVG should still be visible');
                            }
                        } catch (error) {
                            console.error('Error initializing pan/zoom:', error);
                            console.log('SVG should still be visible without pan/zoom');
                        }
                    }, 50);
                } else {
                    console.error('No SVG element found in container');
                }
                
            } catch (error) {
                console.error('Error rendering graph:', error);
                container.innerHTML = `
                    <div class="text-center text-red-400">
                        <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                        </svg>
                        <p class="text-lg font-medium">Failed to render graph</p>
                        <p class="text-sm text-gray-300">${error.message}</p>
                    </div>
                `;
            }
        }

        function showError(message) {
            const container = document.getElementById('errorContainer');
            const messageEl = document.getElementById('errorMessage');
            
            messageEl.textContent = message;
            container.classList.remove('hidden');
        }

        function hideError() {
            const container = document.getElementById('errorContainer');
            container.classList.add('hidden');
        }

        function showResults() {
            const container = document.getElementById('resultsContainer');
            container.classList.remove('hidden');
        }

        function hideResults() {
            const container = document.getElementById('resultsContainer');
            container.classList.add('hidden');
        }

        // Handle window resize to adjust graph container padding
        window.addEventListener('resize', function() {
            adjustGraphContainerForFixedHeader();
        });
    </script>
</body>
</html>
